#!/usr/bin/env python3
"""
Script de validation compl√®te des nouvelles fonctionnalit√©s AppGET
V√©rifie que tous les modules sont correctement install√©s et fonctionnels
"""

import os
import sys
import json
import time
import subprocess
import requests
from datetime import datetime

class Colors:
    GREEN = '\033[92m'
    RED = '\033[91m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    BOLD = '\033[1m'
    END = '\033[0m'

class AppGETValidator:
    def __init__(self):
        self.backend_url = "http://127.0.0.1:8000"
        self.frontend_url = "http://localhost:5173"
        self.results = {
            'total_tests': 0,
            'passed': 0,
            'failed': 0,
            'warnings': 0,
            'tests': []
        }
    
    def log(self, message, level='info'):
        """Logging avec couleurs"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        if level == 'success':
            print(f"{Colors.GREEN}‚úÖ [{timestamp}] {message}{Colors.END}")
        elif level == 'error':
            print(f"{Colors.RED}‚ùå [{timestamp}] {message}{Colors.END}")
        elif level == 'warning':
            print(f"{Colors.YELLOW}‚ö†Ô∏è  [{timestamp}] {message}{Colors.END}")
        elif level == 'info':
            print(f"{Colors.BLUE}‚ÑπÔ∏è  [{timestamp}] {message}{Colors.END}")
        else:
            print(f"[{timestamp}] {message}")
    
    def test(self, test_name, test_func):
        """Ex√©cuter un test et enregistrer le r√©sultat"""
        self.results['total_tests'] += 1
        self.log(f"Test: {test_name}", 'info')
        
        try:
            result = test_func()
            if result:
                self.results['passed'] += 1
                self.log(f"{test_name} - R√âUSSI", 'success')
                self.results['tests'].append({
                    'name': test_name,
                    'status': 'passed',
                    'message': 'OK'
                })
                return True
            else:
                self.results['failed'] += 1
                self.log(f"{test_name} - √âCHEC", 'error')
                self.results['tests'].append({
                    'name': test_name,
                    'status': 'failed',
                    'message': 'Test failed'
                })
                return False
        except Exception as e:
            self.results['failed'] += 1
            self.log(f"{test_name} - ERREUR: {str(e)}", 'error')
            self.results['tests'].append({
                'name': test_name,
                'status': 'error',
                'message': str(e)
            })
            return False
    
    def check_file_exists(self, filepath):
        """V√©rifier qu'un fichier existe"""
        return os.path.exists(filepath)
    
    def check_directory_structure(self):
        """V√©rifier la structure des r√©pertoires"""
        required_dirs = [
            'backend/grades',
            'backend/absences', 
            'backend/pdf_export',
            'frontend/src/components/grades',
            'frontend/src/components/absences',
            'frontend/src/components/pdf',
            'frontend/src/components/notifications'
        ]
        
        for dir_path in required_dirs:
            if not os.path.exists(dir_path):
                return False
        return True
    
    def check_backend_files(self):
        """V√©rifier les fichiers backend essentiels"""
        required_files = [
            'backend/grades/models.py',
            'backend/grades/views.py',
            'backend/grades/urls.py',
            'backend/absences/models.py',
            'backend/absences/views.py',
            'backend/absences/urls.py',
            'backend/pdf_export/models.py',
            'backend/pdf_export/views.py',
            'backend/pdf_export/urls.py',
            'backend/migrate_enhanced_features.py'
        ]
        
        for file_path in required_files:
            if not os.path.exists(file_path):
                return False
        return True
    
    def check_frontend_files(self):
        """V√©rifier les fichiers frontend essentiels"""
        required_files = [
            'frontend/src/components/grades/StudentGradesView.tsx',
            'frontend/src/components/absences/AbsenceManagement.tsx',
            'frontend/src/components/pdf/PDFExportCenter.tsx',
            'frontend/src/components/notifications/NotificationCenter.tsx',
            'frontend/src/services/enhancedAPI.ts',
            'frontend/src/types/enhanced.ts',
            'frontend/src/hooks/useEnhancedFeatures.ts'
        ]
        
        for file_path in required_files:
            if not os.path.exists(file_path):
                return False
        return True
    
    def check_backend_server(self):
        """V√©rifier que le serveur backend r√©pond"""
        try:
            response = requests.get(f"{self.backend_url}/admin/", timeout=5)
            return response.status_code in [200, 302]  # 302 = redirection vers login
        except:
            return False
    
    def check_api_endpoints(self):
        """V√©rifier les endpoints API"""
        endpoints = [
            '/api/grades/',
            '/api/absences/',
            '/api/pdf-export/',
            '/api/notifications/'
        ]
        
        for endpoint in endpoints:
            try:
                response = requests.get(f"{self.backend_url}{endpoint}", timeout=5)
                # API doit exister (pas 404)
                if response.status_code == 404:
                    return False
            except:
                return False
        return True
    
    def check_frontend_server(self):
        """V√©rifier que le serveur frontend r√©pond"""
        try:
            response = requests.get(self.frontend_url, timeout=5)
            return response.status_code == 200
        except:
            return False
    
    def check_docker_compose(self):
        """V√©rifier la configuration Docker"""
        return os.path.exists('docker-compose.yml') and os.path.exists('Dockerfile')
    
    def check_documentation(self):
        """V√©rifier la documentation"""
        docs = [
            'NOUVELLES_FONCTIONNALITES.md',
            'DEPLOIEMENT_PRODUCTION.md',
            'README.md'
        ]
        
        for doc in docs:
            if not os.path.exists(doc):
                return False
        return True
    
    def check_python_dependencies(self):
        """V√©rifier les d√©pendances Python"""
        try:
            import reportlab
            from PIL import Image
            return True
        except ImportError:
            return False
    
    def check_django_migrations(self):
        """V√©rifier les migrations Django"""
        if not os.path.exists('backend/manage.py'):
            return False
        
        try:
            os.chdir('backend')
            result = subprocess.run([
                'python', 'manage.py', 'showmigrations', '--plan'
            ], capture_output=True, text=True, timeout=30)
            os.chdir('..')
            return result.returncode == 0
        except:
            if os.getcwd().endswith('backend'):
                os.chdir('..')
            return False
    
    def run_all_tests(self):
        """Ex√©cuter tous les tests"""
        print(f"{Colors.BOLD}üöÄ VALIDATION APPGET - NOUVELLES FONCTIONNALIT√âS{Colors.END}")
        print("=" * 60)
        
        # Tests de structure
        self.test("Structure des r√©pertoires", self.check_directory_structure)
        self.test("Fichiers backend", self.check_backend_files)
        self.test("Fichiers frontend", self.check_frontend_files)
        self.test("Configuration Docker", self.check_docker_compose)
        self.test("Documentation", self.check_documentation)
        
        # Tests de d√©pendances
        self.test("D√©pendances Python", self.check_python_dependencies)
        self.test("Migrations Django", self.check_django_migrations)
        
        # Tests de serveurs (optionnels)
        if self.test("Serveur backend", self.check_backend_server):
            self.test("Endpoints API", self.check_api_endpoints)
        
        self.test("Serveur frontend", self.check_frontend_server)
        
        # R√©sum√© final
        self.print_summary()
    
    def print_summary(self):
        """Afficher le r√©sum√© des tests"""
        print("\n" + "=" * 60)
        print(f"{Colors.BOLD}üìä R√âSUM√â DE LA VALIDATION{Colors.END}")
        print("=" * 60)
        
        total = self.results['total_tests']
        passed = self.results['passed']
        failed = self.results['failed']
        
        print(f"Tests ex√©cut√©s: {total}")
        print(f"{Colors.GREEN}R√©ussis: {passed}{Colors.END}")
        print(f"{Colors.RED}√âchecs: {failed}{Colors.END}")
        
        success_rate = (passed / total * 100) if total > 0 else 0
        print(f"Taux de r√©ussite: {success_rate:.1f}%")
        
        if success_rate >= 90:
            self.log("üéâ VALIDATION EXCELLENTE - Application pr√™te pour la production !", 'success')
            status = "EXCELLENT"
        elif success_rate >= 75:
            self.log("‚úÖ VALIDATION BONNE - Quelques am√©liorations possibles", 'success') 
            status = "BON"
        elif success_rate >= 50:
            self.log("‚ö†Ô∏è VALIDATION MOYENNE - Corrections recommand√©es", 'warning')
            status = "MOYEN"
        else:
            self.log("‚ùå VALIDATION INSUFFISANTE - Corrections n√©cessaires", 'error')
            status = "INSUFFISANT"
        
        # Afficher les d√©tails des √©checs
        if failed > 0:
            print(f"\n{Colors.RED}D√©tails des √©checs:{Colors.END}")
            for test in self.results['tests']:
                if test['status'] in ['failed', 'error']:
                    print(f"  ‚ùå {test['name']}: {test['message']}")
        
        # G√©n√©rer un rapport JSON
        report = {
            'timestamp': datetime.now().isoformat(),
            'status': status,
            'success_rate': success_rate,
            'results': self.results
        }
        
        with open('validation_report.json', 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"\nüìÑ Rapport d√©taill√© sauvegard√©: validation_report.json")
        
        # Recommandations
        print(f"\n{Colors.BLUE}üí° RECOMMANDATIONS:{Colors.END}")
        
        if success_rate < 100:
            print("1. Corriger les tests en √©chec avant le d√©ploiement")
        
        if not self.check_backend_server():
            print("2. D√©marrer le serveur backend: cd backend && python manage.py runserver")
        
        if not self.check_frontend_server():
            print("3. D√©marrer le serveur frontend: cd frontend && npm run dev")
        
        print("4. Ex√©cuter les tests automatis√©s: python backend/tests/test_enhanced_features.py")
        print("5. Consulter la documentation: NOUVELLES_FONCTIONNALITES.md")
        
        print(f"\n{Colors.BOLD}AppGET est maintenant √©quip√© de fonctionnalit√©s avanc√©es ! üöÄ{Colors.END}")

def main():
    """Fonction principale"""
    # V√©rifier qu'on est dans le bon r√©pertoire
    if not os.path.exists('backend') or not os.path.exists('frontend'):
        print(f"{Colors.RED}‚ùå Ce script doit √™tre ex√©cut√© depuis la racine du projet AppGET{Colors.END}")
        sys.exit(1)
    
    validator = AppGETValidator()
    validator.run_all_tests()

if __name__ == "__main__":
    main()
